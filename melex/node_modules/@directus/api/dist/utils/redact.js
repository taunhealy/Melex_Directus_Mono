import { isObject } from '@directus/utils';
/**
 * Redact values at certain paths in an object.
 * @param input Input object in which values should be redacted.
 * @param paths Nested array of object paths to be redacted (supports `*` for shallow matching, `**` for deep matching).
 * @param replacement Replacement the values are redacted by.
 * @returns Redacted object.
 */
export function redact(input, paths, replacement) {
    const wildcardChars = ['*', '**'];
    const clone = structuredClone(input);
    const visited = new WeakSet();
    traverse(clone, paths);
    return clone;
    function traverse(object, checkPaths) {
        if (checkPaths.length === 0) {
            return;
        }
        visited.add(object);
        const globalCheckPaths = [];
        for (const key of Object.keys(object)) {
            const localCheckPaths = [];
            for (const [index, path] of [...checkPaths].entries()) {
                const [current, ...remaining] = path;
                const escapedKey = wildcardChars.includes(key) ? `\\${key}` : key;
                switch (current) {
                    case escapedKey:
                        if (remaining.length > 0) {
                            localCheckPaths.push(remaining);
                        }
                        else {
                            object[key] = replacement;
                            checkPaths.splice(index, 1);
                        }
                        break;
                    case '*':
                        if (remaining.length > 0) {
                            globalCheckPaths.push(remaining);
                            checkPaths.splice(index, 1);
                        }
                        else {
                            object[key] = replacement;
                        }
                        break;
                    case '**':
                        if (remaining.length > 0) {
                            const [next, ...nextRemaining] = remaining;
                            if (next === escapedKey) {
                                if (nextRemaining.length === 0) {
                                    object[key] = replacement;
                                }
                                else {
                                    localCheckPaths.push(nextRemaining);
                                }
                            }
                            else if (next !== undefined && wildcardChars.includes(next)) {
                                localCheckPaths.push(remaining);
                            }
                            else {
                                localCheckPaths.push(path);
                            }
                        }
                        else {
                            object[key] = replacement;
                        }
                        break;
                }
            }
            const value = object[key];
            if (isObject(value) && !visited.has(value)) {
                traverse(value, [...globalCheckPaths, ...localCheckPaths]);
            }
        }
    }
}
